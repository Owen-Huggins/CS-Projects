#include "main.h"
#include "gba.h"
#include <stdio.h>
#include <stdlib.h>
#include "images/StartScreen.h"
#include "images/OverScreen.h"
#include "images/WinScreen.h"
#include "images/character.h"
#include "images/garbage.h"
#include "images/DonkeyKong.h"

#include <time.h>




/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.


int main(void) {

  REG_DISPCNT = MODE3 | BG2_ENABLE;
  videoBuffer[1208] = 0x7fff;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  GBASTATE state = START;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
      drawFullScreenImageDMA(StartScreen);
      state = STARTTEXT;
      break;

      case STARTTEXT:
      drawString(80, 100, "MAZE", WHITE);
      if (KEY_DOWN(BUTTON_START, currentButtons)) {
        state = PLAYCLEAR;
      }
        break;

      case PLAYCLEAR:
      fillScreenDMA(BLACK);
      state = PLAY;
      break;

      case PLAY:
      playMaze(&state);



        // state = ?
        break;
      case WIN:
        drawFullScreenImageDMA(WinScreen);

        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          state = PLAYCLEAR;
        } else if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }
        break;

      case LOSE:
        drawFullScreenImageDMA(OverScreen);
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          state = PLAYCLEAR;
        } else if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }

        // state = ?
        break;

    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}





void delay(void) {
  volatile int x = 0;
  for (int i = 0; i < 10000; i++) {
    x++;
  }
}




void playMaze(GBASTATE *state) {
  u32 buttons;

  // finish line
  drawRectDMA(0, 190, 50, 190, GREEN);
  // player
  drawRectDMA(60, 0, 5, 5, YELLOW);
  // coins
  drawRectDMA(60, 5, 5, 5, BLUE);

  //enemy
  drawRectDMA(60, 100, 10, 10, RED);
  // DK
  drawImageDMA(69, 69, 50, 37, DonkeyKong);




  int x = 0;
  int y = 0;

  while (*state == PLAY) {
    waitForVBlank();
    buttons = BUTTONS;

    if (((x == 1) &&  (y >= -2 && y <= 3) ) ) {
        drawString(0, 175, "1", WHITE);
    }

    if ((x == 100) &&  (y >= -2 && y <= 3)) {
      *state = LOSE;
      return;
    }

      if (KEY_DOWN(BUTTON_RIGHT, buttons)) {
          x = x + 1;
          drawRectDMA(60 + y, 0 + x, 5, 5, YELLOW);
          delay();
      }
      if (60 - y < 120) {
       if (KEY_DOWN(BUTTON_UP, buttons)) {
            y = y - 1;
          drawRectDMA(60 + y, 0 + x, 5, 5, YELLOW);
          delay();
        }
      }
      if (60 - y > -30) {
       if (KEY_DOWN (BUTTON_DOWN, buttons)) {
        y = y + 1;
        drawRectDMA(60 + y, 0 + x, 5, 5, YELLOW);
        delay();
        }
      }
      if (x > 5) {
       if (KEY_DOWN(BUTTON_LEFT, buttons)) {
        x = x - 1;
        drawRectDMA(60 + y, 0 + x, 5, 5, YELLOW);
        delay();
        }
      }

      if (KEY_DOWN(BUTTON_SELECT, buttons)) {
        fillScreenDMA(BLACK);
        *state = START;
        return;
      }
      if (x == 185) {
        *state = WIN;
        return;
      }

  }

}
